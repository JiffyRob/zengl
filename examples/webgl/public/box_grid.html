<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body class="example">
  <canvas id="zengl-canvas", tabindex="1" width="1280" height="720"></canvas>
</body>
<script src="https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js"></script>
<script src="webgl.js"></script>
<script>
  (async () => {
    const pyodide = await loadPyodide();

    await pyodide.loadPackage([
      'zengl-1.12.0-cp311-cp311-emscripten_3_1_32_wasm32.whl',
      'webgl-0.1.0-cp311-cp311-emscripten_3_1_32_wasm32.whl',
    ]);

    zenglSetup(pyodide, document.getElementById('zengl-canvas'));
    pyodide.runPython(document.getElementById('python').innerHTML);
  })();
</script>
<script id="python" type="application/x-python-code">
  from math import cos, sin

  import webgl
  import zengl

  window = webgl.window
  ctx = zengl.context()

  image = ctx.image(window.size, 'rgba8unorm', texture=False)
  depth = ctx.image(window.size, 'depth24plus', texture=False)
  image.clear_value = (0.0, 0.0, 0.0, 1.0)

  uniform_buffer = ctx.buffer(size=64)

  boxgrid = ctx.pipeline(
      vertex_shader='''
          #version 300 es
          precision highp float;

          layout (std140) uniform Common {
              mat4 mvp;
          };

          vec3 vertices[36] = vec3[](
              vec3(-0.5, -0.5, -0.5),
              vec3(-0.5, 0.5, -0.5),
              vec3(0.5, 0.5, -0.5),
              vec3(0.5, 0.5, -0.5),
              vec3(0.5, -0.5, -0.5),
              vec3(-0.5, -0.5, -0.5),
              vec3(-0.5, -0.5, 0.5),
              vec3(0.5, -0.5, 0.5),
              vec3(0.5, 0.5, 0.5),
              vec3(0.5, 0.5, 0.5),
              vec3(-0.5, 0.5, 0.5),
              vec3(-0.5, -0.5, 0.5),
              vec3(-0.5, -0.5, -0.5),
              vec3(0.5, -0.5, -0.5),
              vec3(0.5, -0.5, 0.5),
              vec3(0.5, -0.5, 0.5),
              vec3(-0.5, -0.5, 0.5),
              vec3(-0.5, -0.5, -0.5),
              vec3(0.5, -0.5, -0.5),
              vec3(0.5, 0.5, -0.5),
              vec3(0.5, 0.5, 0.5),
              vec3(0.5, 0.5, 0.5),
              vec3(0.5, -0.5, 0.5),
              vec3(0.5, -0.5, -0.5),
              vec3(0.5, 0.5, -0.5),
              vec3(-0.5, 0.5, -0.5),
              vec3(-0.5, 0.5, 0.5),
              vec3(-0.5, 0.5, 0.5),
              vec3(0.5, 0.5, 0.5),
              vec3(0.5, 0.5, -0.5),
              vec3(-0.5, 0.5, -0.5),
              vec3(-0.5, -0.5, -0.5),
              vec3(-0.5, -0.5, 0.5),
              vec3(-0.5, -0.5, 0.5),
              vec3(-0.5, 0.5, 0.5),
              vec3(-0.5, 0.5, -0.5)
          );

          out vec3 v_color;

          vec3 hsv2rgb(vec3 c) {
              vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
              vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
              return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }

          float hash13(vec3 p3) {
              p3 = fract(p3 * 0.1031);
              p3 += dot(p3, p3.zyx + 31.32);
              return fract((p3.x + p3.y) * p3.z);
          }

          void main() {
              int N = 10;
              float px = float(gl_InstanceID % N);
              float py = float(gl_InstanceID / N % N);
              float pz = float(gl_InstanceID / N / N % N);
              vec3 position = vec3(px, py, pz) - float(N - 1) / 2.0;
              float scale = 0.1;
              gl_Position = mvp * vec4(position + vertices[gl_VertexID] * scale, 1.0);
              v_color = hsv2rgb(vec3(hash13(position), 1.0, 0.5));
          }
      ''',
      fragment_shader='''
          #version 300 es
          precision highp float;

          in vec3 v_color;

          layout (location = 0) out vec4 out_color;

          void main() {
              out_color = vec4(pow(v_color, vec3(1.0 / 2.2)), 1.0);
          }
      ''',
      layout=[
          {
              'name': 'Common',
              'binding': 0,
          },
      ],
      resources=[
          {
              'type': 'uniform_buffer',
              'binding': 0,
              'buffer': uniform_buffer,
          }
      ],
      framebuffer=[image, depth],
      topology='triangles',
      cull_face='back',
      vertex_count=36,
      instance_count=1000,
  )


  def render():
      ctx.new_frame()
      t = window.time * 0.5
      eye = cos(t) * 5.0, sin(t) * 5.0, sin(t * 0.7) * 2.0
      camera = zengl.camera(eye, (0.0, 0.0, 0.0), aspect=window.aspect, fov=45.0)
      uniform_buffer.write(camera)
      image.clear()
      depth.clear()
      boxgrid.render()
      image.blit()
      ctx.end_frame()
</script>
</html>
